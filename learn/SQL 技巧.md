### SQL 技巧

#### 1. 查询SQL尽量不用使用SELECT * ,而是使用 SELECT 具体的字段	
> * 只取需要的字段，节省资源，减少网络开销
> * SELECT * 查询时，很大可能不会使用到覆盖索引，就会引起回表查询

#### 2.如果确定查询结果只有一条或只要最大/最小一条记录，最好使用limit 1
>* 加上limit1后，只要找到对应的一条记录，就不会继续向下扫描了，大大提高了效率
>* 如果查询条件是唯一索引，就没必要加上LIMIT 1 了，LIMIT存在就是为了防止全表扫描而提高性能，如果查询语句可以预知不用全表扫描，加不加LIMIT，性能差别不大

#### 3. 尽量避免在WHERE子句中使用OR来连接条件,建议改成union all  

>* 使用OR时，可能会使索引失效，从而全表扫描
>* 假如两个查询条件，第一个走了索引，第二个没走索引，则可能是全表扫描+索引扫描+合并，MYSQL是有优化器的，处于效率与成本考虑，遇到OR条件，索引可能会失效，直接走全表扫描

#### 4. 优化模糊查询，like查询时尽量把%放关键字后面 

> * 前导模糊查询时（%放关键字前面），索引会失效

#### 5. 尽量不要在索引列上使用内置函数或表达式操作 

~~~sql
#反例
where DATE_ADD(loginTime,Interval 7 day) >=now() 
where age-1=18
#正例
where loginTime>=DATE_ADD(now(),Interval -7 day)
where age=19
~~~

> * 前面写法可能让MYSQL优化器发现走索引比不走索引成本高，从而放弃走索引
> * 有些字段需要计算的，最好是放在业务层，不要放到数据库层,除了节省数据的CPU，还有意想不到的查询缓存优化效果( **多次调用，传入的SQL相同，才可以利用查询缓存** )

#### 6. 应尽量避免在 where 子句中使用负向条件操作符，否则将引擎放弃使用索引而进行全表扫描 

> * != / <> / not in / not exists /is null /is not null 使用这些可能让MYSQL优化器发现走索引比不走索引成本高，从而放弃走索引
> * 可以优化为in查询 
> * 主要指辅助索引，如果在主键索引上使用还是会使用范围索引(性能也不高，也不建议使用)

#### 7. 组合索引，最左匹配原则 

> * 当我们创建一个联合索引的时候，如（k1，k2，k3），相当于创建了（k1）、（k1，k2）和（k1，k2，k3）三个索引，这就是最左匹配原则
>
> * 联合索引不满足最左原则，索引一般会失效，但是这个还跟 MySQL 优化器有关的

#### 8. 类型转换会全表扫描 

> * 如果字段类型是字符串，where后面一定要用引号括起来
> * 不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL 会做隐式的类型转换 

#### 9. 数据区分度不大的字段不宜使用索引 

> * 经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引 
> * 因为 SQL 优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，MySQL 查询优化器推算发现不走索引的成本更低，很可能就放弃索引了 

#### 10. 允许为null的列，查询结果可能不符合预期 

> * 尽量使用not null约束以及使用默认值
> * 单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到不符合预期的结果集

#### 11. exists 和 in 的合理使用 

~~~sql
select * from A where bId in (select id from B);
~~~

> * MySQL 优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优 
> * 我们要选择最外层循环小的，也就是，如果 B 的数据量小于 A，适合使用 in，如果 B 的数据量大于 A，即适合选择 exist 

#### 12.尽量用 union all 替换 union

> * union不管结果有没有重复，都会进行合并，然后输出最终结果前排序
> * 如果知道查询结果没有重复记录，使用union all 会提高效率

#### 13. 索引不要太多，最好是5个以内 

> * 当插入和更新时会重建索引，索引太多会影响效率
> * 删除冗余和重复的索引，优化器在优化查询的时候需要逐个考虑，太多了会影响性能

#### 14. 尽可能使用varchar/nvarchar代替char/nchar 

> * 变长字段存储空间小，节省空间
> * 对于查询来说，在一个相对较小的字段内查询效率更高

#### 15. 为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉 

~~~sql
select level，avg（balance） from member where level ='ag' 
or level = 'hag' group by level；
~~~

> 最好先条件过滤再分组

#### 16. 表连接查询不要太多表，最好不超过5张表  

> * 连表越多，编译的时间和开销就越大
> * 连表时尽量使用别名，并把别名前缀于每个列上，语义更加清晰

#### 17. Inner join 、left join、right join，优先使用 Inner join，如果是 left join，左边表结果尽量小 

> * 如果 inner join 是等值连接，或许返回的行数比较少，所以性能相对会好一点 
> * 使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。 

#### 18. 如果数据量太大，建议分批操作 

> * 一次性删除太多数据，可能会有 lock wait timeout exceed 的错误，所以建议分批操作。 
> * 同时修改或删除过多数据，会占用太多CPU资源，影响别人的操作
> * 查询返回过多数据也影响性能，客户也不需要一次查看太多数据,建议分批操作

#### 19. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型 

> * 相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销 

#### 20. limit分页优化 

~~~sql
select id，name from member limit 10000，10
优化一:
select id，name from member where id>10000 limit 10
优化二:
select id，name from member order by id limit 10000, 10
~~~

> * 优化一，记录上次的最大偏移量，跳过偏移量
> * 优化二，ordery by+索引，也可以提高效率

#### 21. 使用 explain 分析你 SQL 的计划 

